% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dataprepmodelplots.R
\name{prepare_scores_and_ntiles}
\alias{prepare_scores_and_ntiles}
\title{Build a dataframe containing Actuals, Probabilities and Ntiles}
\usage{
prepare_scores_and_ntiles(datasets, dataset_labels, models, model_labels,
  target_column, ntiles = 10)
}
\arguments{
\item{datasets}{List of Strings. A list of the names of the dataframe
objects to include in model evaluation. All dataframes need to contain
target variable and feature variables.}

\item{dataset_labels}{List of Strings. A list of labels for the datasets, user.
When dataset_labels is not specified, the names from \code{datasets} are used.}

\item{models}{List of Strings. Names of the model objects containing parameters to
apply models to data. To use this function, model objects need to be generated
by the mlr package or by the caret package or by the h20 package.
Modelplotr automatically detects whether the model is built using mlr or caret or h2o.}

\item{model_labels}{List of Strings. Labels for the models to use in plots.
When model_labels is not specified, the names from \code{moddels} are used.}

\item{target_column}{String. Name of the target variable in datasets. Target
can be either binary or multinomial. Continuous targets are not supported.}

\item{ntiles}{Integer. Number of ntiles. The ntile parameter represents the specified number
of equally sized buckets the observations in each dataset are grouped into.
By default, observations are grouped in 10 equally sized buckets, often referred to as deciles.}
}
\value{
Dataframe. A dataframe is built, based on the \code{datasets}
  and \code{models} specified. It contains the dataset name, actuals on the \code{target} ,
  the predicted probabilities for each class of the target and attribution to
  ntiles in the dataset for each class of the target.
}
\description{
Build dataframe object that contains actuals and predictions on
the target variable for each dataset in datasets and each model in models
}
\section{When you build scores_and_ntiles yourself}{

To make plots with modelplotr, is not required to use this function to generate input for function \code{plotting_scope}
You can create your own dataframe containing actuals and predictions and ntiles,
Please do check the required input for the \code{\link{aggregate_over_ntiles}} function if you
want to use that function to aggregate actuals and predictions
}

\examples{
data(iris)
# add some noise to iris to prevent perfect models
addNoise <- function(x) round(rnorm(n=100,mean=mean(x),sd=sd(x)),1)
iris_addnoise <- as.data.frame(lapply(iris[1:4], addNoise))
iris_addnoise$Species <- sample(unique(iris$Species),100,replace=TRUE)
iris <- rbind(iris,iris_addnoise)
train_index =  sample(seq(1, nrow(iris)),size = 0.7*nrow(iris), replace = F )
train = iris[train_index,]
test = iris[-train_index,]
#train models using mlr...
trainTask <- mlr::makeClassifTask(data = train, target = "Species")
testTask <- mlr::makeClassifTask(data = test, target = "Species")
mlr::configureMlr() # this line is needed when using mlr without loading it (mlr::)
task = mlr::makeClassifTask(data = train, target = "Species")
lrn = mlr::makeLearner("classif.randomForest", predict.type = "prob")
rf = mlr::train(lrn, task)
lrn = mlr::makeLearner("classif.multinom", predict.type = "prob")
mnl = mlr::train(lrn, task)
#... or train models using caret...
rf = caret::train(Species ~.,data = train, method = "rf")
mnl = caret::train(Species ~.,data = train, method = "multinom",trace = FALSE)
#.. or train models using h2o
h2o::h2o.init()
h2o::h2o.no_progress()
h2o_train = h2o::as.h2o(train)
h2o_test = h2o::as.h2o(test)
gbm <- h2o::h2o.gbm(y = "Species",
                          x = setdiff(colnames(train), "Species"),
                          training_frame = h2o_train,
                          nfolds = 5)
# preparation steps
scores_and_ntiles <- prepare_scores_and_ntiles(datasets=list("train","test"),
                      dataset_labels = list("train data","test data"),
                      models = list("rf","mnl", "gbm"),
                      model_labels = list("random forest","multinomial logit", "gradient boosting machine"),
                      target_column="Species")
plot_input <- plotting_scope(prepared_input = scores_and_ntiles)
plot_cumgains(data = plot_input)
plot_cumlift(data = plot_input)
plot_response(data = plot_input)
plot_cumresponse(data = plot_input)
plot_multiplot(data = plot_input)
plot_costsrevs(data = plot_input,fixed_costs = 1000,variable_costs_per_unit = 10,profit_per_unit = 50)
plot_profit(data = plot_input,fixed_costs = 1000,variable_costs_per_unit = 10,profit_per_unit = 50)
plot_roi(data = plot_input,fixed_costs = 1000,variable_costs_per_unit = 10,profit_per_unit = 50)
}
\seealso{
\code{\link{modelplotr}} for generic info on the package \code{moddelplotr}

\code{\link{plotting_scope}} for details on the function \code{plotting_scope} that
transforms a dataframe created with  \code{prepare_scores_and_ntiles} or \code{aggregate_over_ntiles} to
a dataframe in the required format for all modelplotr plots.

\code{\link{aggregate_over_ntiles}} for details on the function \code{aggregate_over_ntiles} that
aggregates the output of \code{prepare_scores_and_ntiles} to create a dataframe with aggregated actuals and predictions.
In most cases, you do not need to use it since the \code{plotting_scope} function will call this function automatically.

\url{https://github.com/modelplot/modelplotr} for details on the package

\url{https://modelplot.github.io/} for our blog on the value of the model plots
}
